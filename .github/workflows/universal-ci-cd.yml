---
name: Universal CI/CD

on:
  workflow_call:
    inputs:
      config-path:
        description: 'Path to ci-config.yml in the caller repo'
        required: true
        type: string
    secrets:
      dockerhub-username:
        description: 'Docker Hub username'
        required: true
      dockerhub-token:
        description: 'Docker Hub token'
        required: true
      ssh-host:
        description: 'Target server host'
        required: true
      ssh-username:
        description: 'SSH username on the target server'
        required: true
      ssh-private-key:
        description: 'SSH private key (PEM format)'
        required: true
      ssh-port:
        description: 'SSH port (optional, defaults to 22)'
        required: false

jobs:
  load-config:
    runs-on: ubuntu-latest
    outputs:
      test_branches: ${{ steps.cfg.outputs.test_branches || 'main, master, development' }}
      deploy_branches: ${{ steps.cfg.outputs.deploy_branches || 'main, master' }}
      registry: ${{ steps.cfg.outputs.registry }}
      image_prefix: ${{ steps.cfg.outputs.image_prefix }}
      test_compose: ${{ steps.cfg.outputs.test_compose }}
      test_service: ${{ steps.cfg.outputs.test_service }}
      test_command: ${{ steps.cfg.outputs.test_command }}
      compose_remote_path: ${{ steps.cfg.outputs.compose_remote_path }}
      services: ${{ steps.cfg.outputs.services }}
    steps:
      - name: Checkout caller repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML jq

      - name: Load CI/CD config
        id: load_config
        env:
          CONFIG_PATH: ${{ inputs.config-path }}
        run: |
          python << 'EOF'
          import yaml
          import json
          import os
          import sys

          config_path = os.environ['CONFIG_PATH']
          try:
              with open(config_path, 'r', encoding='utf-8') as f:
                  config = yaml.safe_load(f)
              print(json.dumps(config, indent=2))
              with open('ci-config.json', 'w') as f:
                  json.dump(config, f, indent=2)
              sys.exit(0)
          except Exception as e:
              print(f"Error loading config: {e}")
              sys.exit(1)
          EOF


      - name: Parse config and set outputs
        id: cfg
        run: |
          CONFIG=$(cat ci-config.json)

          # Ветки
          echo "test_branches=$(echo "$CONFIG" | jq -r '.test.branches | join(",")')" >> $GITHUB_OUTPUT
          echo "deploy_branches=$(echo "$CONFIG" | jq -r '.deploy.branches | join(",")')" >> $GITHUB_OUTPUT

          # Docker
          echo "registry=$(echo "$CONFIG" | jq -r '.docker.registry')" >> $GITHUB_OUTPUT
          echo "image_prefix=$(echo "$CONFIG" | jq -r '.docker.image_prefix')" >> $GITHUB_OUTPUT

          # Тесты
          echo "test_compose=$(echo "$CONFIG" | jq -r '.test.compose_file')" >> $GITHUB_OUTPUT
          echo "test_service=$(echo "$CONFIG" | jq -r '.test.test_service')" >> $GITHUB_OUTPUT
          echo "test_command=$(echo "$CONFIG" | jq -r '.test.test_command')" >> $GITHUB_OUTPUT

          # Деплой
          echo "compose_remote_path=$(echo "$CONFIG" | jq -r '.deploy.compose_remote_path')" >> $GITHUB_OUTPUT

          # Список сервисов (как base64-строки)
          services=$(jq -r '.docker.services[] | @base64' ci-config.json | paste -sd' ')
          echo "services=$services" >> $GITHUB_OUTPUT

  test:
    runs-on: ubuntu-latest
    needs: load-config
    if: contains(format(',{0},', needs.load-config.outputs.test_branches), format(',{0},', github.ref_name))
    steps:
      - name: Checkout caller repository
        uses: actions/checkout@v4

      - name: Set up Docker
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Run tests
        run: |
          if [ -z "${{ needs.load-config.outputs.test_compose }}" ] || [ "${{ needs.load-config.outputs.test_compose }}" = "null" ]; then
            echo "No test compose file defined, skipping tests."
            exit 0
          fi

          if [ -z "${{ needs.load-config.outputs.test_service }}" ] || [ "${{ needs.load-config.outputs.test_service }}" = "null" ]; then
            echo "No test service defined, skipping tests."
            exit 0
          fi

          set -e
          docker compose -f ${{ needs.load-config.outputs.test_compose }} up -d
          docker compose -f ${{ needs.load-config.outputs.test_compose }} exec -T ${{ needs.load-config.outputs.test_service }} sh -c "${{ needs.load-config.outputs.test_command }}"
          docker compose -f ${{ needs.load-config.outputs.test_compose }} down

  deploy:
    runs-on: ubuntu-latest
    needs: [load-config, test]
    if: contains(format(',{0},', needs.load-config.outputs.deploy_branches), format(',{0},', github.ref_name)) && needs.test.result == 'success'

    steps:
      - name: Checkout caller repository
        uses: actions/checkout@v4

      - name: Set up Docker
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/amd64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.dockerhub-username }}
          password: ${{ secrets.dockerhub-token }}

      - name: Build and push images
        run: |
          echo "${{ needs.load-config.outputs.services }}" | tr ' ' '\n' | while IFS= read -r service_b64; do
            service_json=$(echo "$service_b64" | base64 -d)
            name=$(echo "$service_json" | jq -r '.name')
            dockerfile=$(echo "$service_json" | jq -r '.dockerfile')
            context=$(echo "$service_json" | jq -r '.context')

            image_name="${{ needs.load-config.outputs.registry }}/${{ needs.load-config.outputs.image_prefix }}-${name}:${{ github.sha }}"
            echo "Building and pushing $image_name"

            docker build --file "$dockerfile" --tag "$image_name" "$context"
            docker push "$image_name"
          done


      - name: Generate docker-compose on runner
        run: |
          python - <<'PY'
          import json, yaml, os
          with open('ci-config.json', 'r', encoding='utf-8') as f:
              cfg = json.load(f)

          services = cfg.get('docker', {}).get('services', [])
          registry = os.environ.get('REGISTRY')
          prefix = os.environ.get('IMAGE_PREFIX')
          sha = os.environ.get('GITHUB_SHA')

          out = {'version': '3', 'services': {}}
          for s in services:
              name = s.get('name')
              if not name:
                  continue
              image = f"{registry}/{prefix}-{name}:{sha}"
              svc = {'image': image, 'restart': 'unless-stopped'}
              if s.get('container_name'):
                  svc['container_name'] = s.get('container_name')
              out['services'][name] = svc

          os.makedirs('deploy', exist_ok=True)
          with open('deploy/docker-compose.yml', 'w', encoding='utf-8') as f:
              yaml.safe_dump(out, f, sort_keys=False)
          PY
        env:
          REGISTRY: ${{ needs.load-config.outputs.registry }}
          IMAGE_PREFIX: ${{ needs.load-config.outputs.image_prefix }}
          GITHUB_SHA: ${{ github.sha }}

      - name: Ensure remote deploy directory exists
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ssh-host }}
          username: ${{ secrets.ssh-username }}
          key: ${{ secrets.ssh-private-key }}
          port: ${{ secrets.ssh-port || 22 }}
          script: |
            set -e
            mkdir -p "$(dirname '${{ needs.load-config.outputs.compose_remote_path }}')"

      - name: Upload compose to server via SCP
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.ssh-host }}
          username: ${{ secrets.ssh-username }}
          key: ${{ secrets.ssh-private-key }}
          port: ${{ secrets.ssh-port || 22 }}
          source: deploy/docker-compose.yml
          target: ${{ needs.load-config.outputs.compose_remote_path }}

      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.ssh-host }}
          username: ${{ secrets.ssh-username }}
          key: ${{ secrets.ssh-private-key }}
          port: ${{ secrets.ssh-port || 22 }}
          script: |
            set -e
            REMOTE_PATH='${{ needs.load-config.outputs.compose_remote_path }}'
            DEPLOY_DIR=$(dirname "$REMOTE_PATH")

            # Detect docker compose command availability
            if command -v docker >/dev/null 2>&1; then
              if docker compose version >/dev/null 2>&1; then
                COMPOSE_CMD="docker compose"
              elif command -v docker-compose >/dev/null 2>&1; then
                COMPOSE_CMD="docker-compose"
              else
                echo "Error: neither 'docker compose' nor 'docker-compose' found on remote host" >&2
                exit 1
              fi
            else
              echo "Error: 'docker' CLI not found on remote host" >&2
              exit 1
            fi

            cd "$DEPLOY_DIR"
            $COMPOSE_CMD down || true
            $COMPOSE_CMD pull
            $COMPOSE_CMD up -d
            echo "Deploy completed."
